next : 완료
        *일단 1depth(지금 오브젝트 파일 하나있고, Makefile하나있는 수준으로 빌드어떻게 하는지 분석 ㄱㄱㄱㄱ)
        9단계전까지는 테스트머신내, /home/knw/Desktop/my_module 을 실습에 사용한다.(내용은 현단계에서 안중요함)
*1-10단계학습법 적용
*참고.
  1-6단계, 목표, 계획, 학습데이터 모으는 단계
  7단계(대충 사용 수준까지)
  8단계(이것저것해보기)
  9단계(유용한 것을 할수있는 수준까지 파기)
  10단계(가르치기)

주제 : kernel module build / load 동작 확인

학습이유
  그나마 자주 마주하는 lowlevel영역인 kernel module의 기본적인 흐름(빌드방법,빌드로직 / load방법,load로직)을 확인한다.
  *단 디바이스드라이버나 기존 나와있는 kernel module을 분석하겠다는 아니다.!

학습목표
  out of tree(=external) kernel module build 방법흐름(그대로 따라했을 때 빌드되야함)과 이에 대한 빌드 로직 분석
  out of tree kernel module load load방법흐름(그대로 따라했을 때 load되어야함)과 이에 대한 로직(큰 흐름 ex. 함수호출흐름) 분석
  hello.ko 빌드하여 load를 한다.
    
학습자료
  $(top)/Documentation/kbuild/modules.rst
  이것저것 많다.

학습계획
  milestone1. out of tree kerneml module build / load 동작분석
  
================================================================
7단계 *목표 : out of tree kernel module build / load 동작분석
7-1. out of tree kernel build
7-1-1. build방법 
  make -C [path/to/kernel/src] M=[path/to/module/src] *module build, 'modules' target 명시해도 동일함.
  make -C [path/to/kernel/src] M=[path/to/module/src] modules_install *module install
    기본적으로 external module은 /lib/modules/$(KERNELRELEASE)/extra 하위에 설치된다.
    INSTALL_MOD_PATH 변수사용해서 위치 변경가능
      ex) make -C [path/to/kernel/src] M=[path/to/module/src] INSTALL_MOD_PATH=/knwtest modules_install
        => /knwtest/lib/modules/$(KERNELRELEASE)/kernel에 설치됨.
    INSTALL_MOD_DIR 변수사용하면 extra대신 다른 경로에 설치된다.
      ex) make -C [path/to/kernel/src] M=[path/to/module/src] INSTALL_MOD_DIR=knwtest modules_install
        => /lib/modules/$(KERNELRELEASE)/knwtest에 설치됨.
  *커널빌드 시, 'O=' option으로 kernel output위치 변경했으면, 'O=' option필수!
  *$(top)/Documentation/kbuild/modules.rst 참조

7-1-2. build로직 흐름 분석
전체흐름 
  make M=[path/to/module/src] modules시의 실행되는 Makefile 순서/output 흐름.
  $(top)/Makefile : 모듈빌드를 위한 주요변수들 세팅
    $(top)/Makefile.build : *.o, *.mod, modules.order 생성
    $(top)/scripts/Makefile.modpost : (KBUILD_EXTMOD)/Module.symvers, *.mod.c 생성 
      $(top)/scripts/Makefile.modfinal : *.mod.o, *.ko 생성

  *external module 빌드디렉토리내 .cmd파일(hidden file(.으로 시작하는 파일))에 실행했던 command 기록되어있다.! 이거 참고하면 도움 됨.
    $(top)/scripts/Kbuild.include에 정의된 if_changed* 매크로들에서 찍도록 되어있음~
    목적은 잘 모르겠담;(일단 skip)
  *특정 Makefile에 없는 macro / var들은 $(top)/scripts/Kbuild.include 등 공통(?) Makefile에 정의되어있다!(이를 include하여 사용한다.)

  make M=[path/to/module/src] modules_install시의 흐름
    modules_install: *line 1835참조.
    별다른 흐름은 없고 이 rule만 실행한다!
    $(top)/scripts/Makefile.modinst 자체도 직관적이므로 별도 분석은 안함.(mkdir; cp한다음 strip필요하면하고, signing해야하면 하고...압축해야하면하고...)
      dst변수(모듈설치경로)는 $(MODLIB)/$(INSTALL_MOD_DIR) 세팅됨. => 그래서 make인자에 INSTALL_MOD_DIR로 경로 변경할수있다.
      $(MODLIB)도 $(top)/Makefile에 정의되어있음.!(line 1151-1152참조)
             
$(top)/Makefile
  make modules,modules_install target rule과 그에대한 관련변수, prerequisites들이 기술되어있음.

  make M=[path/to/module/src] modules시의 흐름 *간단하게 보여지기 위해 target: prerequisites만 기술함
    prepare: *line 1794-1795
    $(build-dirs): prepare *line 1905
      build-dirs는 external module이 존재하는 위치임(대강 make M= 값이라고 보면 됨. line 1781참조)
    descend: $(build-dirs) *line 1904
    $(MODORDER): descend *line 1782
      MODORDER변수값은 line 1156-1157 참조
    modules_check: $(MODORDER) *line 1828
    modules: modules_check *line 1824

  line 130-144
    KBUILD_EXTMOD var 세팅
    make 'M=' 변수값으로 세팅된다!
  line 167-169
    KBUILD_OUTPUT variable 세팅
     즉, 커널빌드 시 'O=' 옵션값을 해당 variable에 세팅한다.
  line 171-176
    abs_objtree variable 세팅
     즉, kernel object output의 절대경로를 세팅한다.
    KBUILT_OUTPUT 값이 not null(= 'O='옵션이 세팅O)
      abs_objtree = 'O=' 인자로 넘어온 경로로 세팅(절대경로)
    null이라면('O=' 옵션이 세팅X)
      abs_objtree = make실행한 경로로 세팅(=결국엔 커널소스 최상위 경로일듯, 절대경로)
  line 192
    abs_srctree var 세팅
    kernel src 가 존재하는 디렉토리의 절대경로를 세팅한다.
  line 239-255
    srctree var 세팅
     kernel src 가 존재하는 디렉토리의 경로를 세팅한다.(경우에따라 relative, absolute인듯.)
    abs_srctree == abs_objtree면, 현재경로(.)으로 세팅
    abs_srctree가 abs_objtree보다 한단계 상위면, 상위(..)으로 세팅
     그외는 abs_srctree로 세팅
    *abs_srctree(line 192참조), abs_objtree(line 171-176참조)
  line 666
    KBUILD_MODULES, KBUILD_BUILTIN 변수 export.
    $(top)/scripts/Makefile.build에서사용됨.
    external module빌드시에는 KBUILD_BUILTIN은 empty, KBUILD_MODULES는 1임(line 1777-1779참조)
    KBUILD_MODULES : module빌드시 1(ex. make modules 또는 kernel자체 빌드(make) 또는 external module 빌드(make M=) 즉, 커널모듈 빌드해야하면 1 안하면 empty.(모듈만하든 커널전체를하든 어쨋든 모듈은 빌드함))
    KBUILD_BUILTIN : module을 빌드하면 empty(ex. make modules시 모듈만 빌드하겠다는 의미)
  line 1156-1157
    extmod_prefix와 MODORDER변수 세팅
    extmod_prefix : $(KBUILD_EXTMOD)/ 로 세팅됨 *line 130-144참조
    MODORDER : $(extmod_prefix)/modues.order로 세팅됨.
  //line 1160-1768
    external module 빌드시에는 신경안써도됨
    KBUILD_EXTMOD 변수(line 130-144참조)세팅되어있으면 이 라인은 통째로 날라감
     *다른 line들도있는데 한눈에 파악가능함. 해당 영역은 너무 long line이라 따로 명시해둠!
  line 1781
    build-dirs 세팅
    KBUILD_EXTMOD 변수로 세팅함(line 130-144참조)
  line 1782-1783
    $(MODORDER) target rule 정의
    prerequisites : descend
  line 1794-1795
    prepare target rule
    외부모듈시에는 특별한 역할은 없음(어보임)
    *목적은 실제 descending하면서 make실행 전 실행되어야 할 target rule을 정의가 목적. line 1248의 주석참조. 
  line 1824
    modules target rule 정의(with recipe)
    prerequisites : modules_check modules_prepare
    recipe : $(srctree)/scripts/Makefile.modpost 을 현재경로(=make modules를 실행한 경로)에서 수행한다.
       하는일은 $(top)/scripts/Makefile.modpost 참조(아래분석내용)
       + 간접적으로 실제 ko파일을 생성한다.!($(top)/scripts/Makefile.modpost에 의해 $(top)/scripts/Makefile.modfinal가 수행됨)
      *srctree변수 (line 239-255 참조)
  line 1827-1828
    module_check target rule 정의
    prerequisites : $(MODORDER) *line 1156-1157참조
    recipe : $(srctree)/scripts/modules-check.sh 스크립트를 실행한다.
      modules.order파일에 중복된 모듈(.ko)가 존재하는 지 확인함. 존재하면 에러 리턴.
  line 1835
    modules_install target rule정의
    prerequisites는 없음
    recipe만 있음
      $(top)/scripts/Makefile.modinst 을 실행
      *signing필요하면 depmod.sh도 실행. 일단 skip
  //line 1858-1896
    단일 파일 빌드(ex. make foo/bar/baz.c)시의 룰. 일단 skip
  line 1904
    descend target 룰
    prerequisites : $(build-dirs) *line 1781참조
  line 1905
    $(build-dirs) target 룰 *line 1781참조
    prerequisites : prepare  *line 1794-1795참조
    recipe
      실제로 external module을 빌드함!
      *recipe에서 single-build 변수는 지금은 skip 0으로보면 됨. *line 1858-1895참조!
  참고
    make $(build)= ~~에서, build 변수는 scripts/Kbuild.include에 정의되어있음 *$(top)/Makefile에서 include함.
      'build := -f $(srctree)/scripts/Makefile.build obj'

$(top)/scripts/Makefile.build
  external module의 소스파일을 컴파일함. 링크는 안함. 즉 .ko는 안만들어짐.
  만들어지는 파일은 다음과 같음(더있지만 일단 분석했던 것들만)
    *.o : 컴파일된 오브젝트파일.  *line 286-290 참조
    *.mod : 컴파일된 오브젝트 파일 목록. *line 313-320 참조
    modules.order : .ko 파일 목록. *line 446-459참조
  line 6
    src 세팅 수행
    인자로넘어몬 obj로 세팅
    obj는 make M= 으로 넘어온 값으로 보면 된다!
  line 41-44
    external module directory에 존재하는 Kbuild 또는 Makefile을 include 함.
  line 89-97
    targets-for-modules 값 세팅
    obj-m변수에 .o확장자를 .mod로변환한한 값이 세팅됨.*obj-m변수는 external module directory에서 세팅된다. line 41-44참조
      ex. obj-m:=my_module.o이면, my_modules.mo 가 세팅
    $(obj)/modules.order도 추가.
  line 269-277
    rule_cc_o_c macro
    .c -> .o 빌드할때 사용될 recipe. (line 286-290참조)
    .c -> .o빌드뿐아니라 src check, dependency관련 작업 등등을 수행(이것들도 일단 skip)
  line 286-290
    .c -> .o build rule
    prerequisites : .c $(recordmcount_source) $(objtool_dep)
      recordmcount_source : ftrace안쓰면(CONFIG_FTRACE_MCOUNT_USE_RECORDMCOUNT) empty 쓸때만 세팅됨. 일단 skip()
      objtool_dep : stack validation(CONFIG_STACK_VALIDATION) 관련. 미사용하면 empty. 일단 skip
    recipe : rule_cc_o_c 매크로를 실행한다! 즉, .c -> .o로 빌드한다. (line 269-277 참조)
  line 313-320
    %.mod target rule
    prerequisites : %$(mod-prelink-ext).o
      mod-prelink-ext는 empty이므로, 결국 %.o 가 된다!
      *mod-prelink-ext는 LTO를 사용(LLVM관련일듯)할때만 세팅됨으로 확인 $(top)/scripts/Makefile.lib 변수/관련주석참조. 일단 skip.
    recipe : cmd_mod 수행
      .mod파일(단순하게 빌드된 파일 목록으로 보면 될 듯) 생성
  line 446-459
    modules.order target rule
    prerequisites : $(obj-m) *line 41-44참조
    recipe : cmd_modules_order 수행. line 454-456참조
      modules.order 생성하는 cmd임.
      obj-m변수값 각각에 대해, modules.order을 제외하고 .o -> .ko로 치환하여 파일에 기록한다고 보면되겠다.
  line 510-545    
    //line 510-537은 skip(single-build(ex. make foo/bar/zar.c)일때만 사용되므로)
    line 540-543
      __build target rule
      prerequisites : $(targets-for-modules) $(subdir-ym) $(always-y)
        *KBUILD_BUILTIN(empty로세팅), KBUILD_MODULES(1로세팅)는 $(top)/Makefile에 의해 export됨($(top)/Makefile line 666 참조)
        targets-for-modules *line 89-97참조
        subdir-ym, always-y : skip. 파일 하나로 되어있는 빌드시에는 사용안하는 듯. 추후 확인...
          *Documentation/kbuild/makefiles.rst보는것도 도움될듯(subdir-y, always-y)
        
$(top)/scripts/Makefile.modpost
  modpost를 실행하여 $(KBUILD_EXTMOD)/Module.symvers 생성한다.
  *.mod.c도 생성한다.(by modpost command에의해 *$(top)/scripts/mod/modpost.c line 2549-2550참조)
  line 47-51
    MODPOST정의
    $(top)/scripts/mod/modpost tool을 실행하는 것이 주요 골자임.
    이후 line들에서도 옵션에 따라 다양한 MODPOST option들을 추가한다.
  //line 53-81은 skip
    external module빌드시에는 상관없음.
  line 85-87
    obj, src변수세팅
    KBUILD_EXTMOD(make M= 값)값으로 세팅($(top)/Makefile로부터(line 130-144참조) export됨!)
  line 89-90
    external module directory(=KBUILD_EXTMOD)로부터 Kbuild or Makefile include
  line 95-96
    input-symdump, output-symdump 변수 정의
    input-symdump : MODPOST input이 될 파일(Module.symvers) *kernel symbol들이라고 보면 될 듯
    output-symdump : MODPOST output이 될 파일($(KBUILD_EXTMOD)/Module.symvers) *external module symbol들이라고 보면 될 듯
  line 120
    modules변수세팅
    cat modules.order 출력으로 세팅함
    *MODORDER는 $(top)/Makefile로부터 export 됨
  line 127-133
    $(output-symdump) target rule 
    prerequisites : $(MODORDER) $(input-symdump) *mod-prelink-ext는 skip(LLVM관련해서일 듯해서 스킵~) 
    recipe : modpost를 수행한다.(MODPOST변수참조)
      *modpost : external module로부터 symbol정보를 추출하는 kernel제공 tool임.($(top)/Documentation/kbuild/modules.rst 6.2참조)
      *line 47-51참조(MODPOST변수정의)
  line 137-140
    __modpost target rule(recipe가 기술된 target rule!, 다른line에는 prerequisites만 기술되어있다.)
    prerequisites : 
    recipe : $(MAKE) -f $(srctree)/scripts/Makefile.modfinal 를 수행
      ko파일을 빌드한다.!
      *KBUILD_MODPOST_NOFINAL은 신경안써도 됨(필요할때 수동으로 1로세팅해서 사용, 일반적으로 빌드할때는 사용하지않음. empty값)

$(top)/scripts/Makefile.modfinal
  MODORDER변수에 기록된 각 모듈에 대해 
  mod.o -> .ko 를 생성한다.
  line 15-16
    modules 변수 세팅
    cat $MODORDER 으로 세팅된다. *MODORDER은 $(top)/Makefile로부터 export됨
  line 18-19
    __modfinal target rule
    prerequisites : $(modules) 
    recipe : N/A
     특별한 recipe는 없고, $(modules)를 빌드함 *line 15-16참조
  line 25-29
    %.mod.o target rule
    prerequisites : %.mod.c *$(top)/scripts/Makefile.modpost에 의해 생성됨.
    recipe : cc_o_c macro실행(line 25-26참조. 쉽게말해 compiler -c -o option으로 실행한다고 보면 됨.)
  line 33-38
    cmd_ld_ko_o macro
    linker를 사용하여 ko파일 링크하는 매크로
    scripts/modules.lds 링커스크립트를 사용하고, 
    input은 $(modules) target rule의 prerequistie(%.mod.o) 임
    *ARCH_POSTLINK가 세팅되어있으면(=  $(srctree)/arch/$(SRCARCH)/Makefile.postlink가 존재하면) 해당 make를 실행. x86에서는 없으므로 skip.
  line 57-62
    $(modules) target rule. *target 명시에 ':' 가 2갠데, gnu make의 static pattern rule 로 보면 됨.(개요는... 여러파일을 한개의 rule로 생성할 수 있다느낌...)
    modules변수에 세팅된 모든 모듈에 대해 ko를 생성한다.(지금은 1개만 하니... 일단 skip)
    prerequisites : %.o %.mod.o scripts/modules.lds 
      *$(mod-prelink-ext), vmlinux는 skip(LLVM관련해서 및 external module일때는 해당하지 않음!)
      *lds파일은 lds.S로부터 해당 룰 실행 전의 시점에 생성됨.($(top)/scripts/Makefile.build line 397-404 참조)
    recipe : ld_ko_o를 수행하여 ko를 생성함.(line 33-38참조)
      *CONFIG_DEBUG_INFO_BTF_MODULES는 debug info 관련으로 보여짐. 일단 skip. ($(top)/Documentation/bpf/btf.rst 참조)

7-2. out of tree kernel load
7-2-1. load/unload방법
  1) insmod / rmmod
  2) modprobe / modprobe -r
  모듈정보조회 : lsmod / modinfo

7-2-2. load로직 흐름 분석 *syscall finit_module syscall
$(top)/kernel/module.c
  line 248-253
    mod_update_bounds
      struct module의 core_layout, init_layout정보를 기반으로 module_addr_min, module_addr_max를 업데이트(by __mod_update_bounds)한다.
      즉, ko의 layout의 min, max address값을 struct mod_tree_root 구조체에 세팅한다.
       *정확한 의미는 모르겠다.
  line 347-360
    find_sec()
      ko파일(ELF)로부터 이름이 name인 섹션의 index를 return한다.
  line 362-367
    section_addr()
      kernel module에서 특정 section의 주소를 return한다.
  line 369-380
    section_objs()
      kernel module에서 특정 section의 주소와, section내부 object갯수를 retrun한다.
  line 513-555
    find_symbol()
      kernel 및 kernel module(kernel에 load된)들의 exported symbol로부터 특정 symbol정보를 찾는다.
      output은
        owner(struct module*)
        crc(s32)
        sym(struct kernel_symbol*)
        license(GPL이냐 아니냐)
       참고. *__ksymtab*은 $(top)/include/asm-generic/vmlinux.lds.h에 정의되어있음.
           __ksymtab 섹션에 정의되는(=EXPORT_SYMBOL매크로로...) 변수들이 모여있다고 보면 되겠다.
           $(top)/include/linux/export.h ___EXPORT_SYMBOL참조(line 87-112)
  line 557-576
    find_module_all()
      인자로넘어온 모듈이름을 가진 struct module 을 modules list에서 찾아서 return한다.
  
  line 590-612
    percpu_modalloc()
    ko파일의 pcpu section size만큼 공간을 할당한다.(by __alloc_reserved_percpu *분석은 skip함)
     아래 필드를 세팅한다.
    struct module->percpu = 할당된공간
    struct module->percpu_size = 할당된 공간의 size

  line 717-742
    MODINFO_ATTR macro
    struct module_attribute modinf_##field를 정의한다.
    modinfo_version, modinfo_srcversion을 해당 매크로로 생성함(line 744-745)

  line 756-772
    module_unload_init()
    struct module의 아래 필드를 초기화한다.
     *아마도 unload를 위한 데이터인듯. CONFIG_MODULE_UNLOAD on일때만 처맇마.
      refcnt = 2
      source_list 초기화 (자기자신에게 의존하는 모듈에 대한 리스트 *struct module 해당 필드 주석참조)
      target_list 초기화 (내가 의존하는 모듈에 대한 리스트 *struct module 해당 필드 주석참조)

  line 1240-1287
    check_version()
      설정(CONFIG_MODVERSIONS)에따라 nop일수도있음.
      대략...
     ko파일의 '__version' section(setup_load_info에서 세팅)에서 특정symbol 버젼이 같은지를 비교한다.
     crc가 같아야 동일, 아니면 다름.
  line 1289-1308
    check_modstruct_version()
      'module_layout' symbol에 대해 version을 check한다(by check_version())

  line 2240-2274
    verify_exported_symbols()
    kernel module의 symbol중 어느하나라도 이미 존재(kernel자체 or 또다른 kernel module)하는지를 체크한다.(by find_symbol)
     존재하는 경우 ENOEXEC를 return한다.

  line 2291-2361
    simplify_symbols()
    kernel module이 가지고있는 모든symbol의 value(=symbol의 메모리내 address)를 세팅(=resolution)한다.
    ABS, COMMON, LIVEPATCH symbol에 대해서는 don't care.

  line 2363-2396
    apply_relocations
    symbol value에 대한 relocation을 수행(by apply_relocate, apply_relocate_add)
    apply_relocate, apply_relocate_add모두 기본적으로는 다음과 같음.
      relocation 적용할 위치를 가져온다(loc variable)
      loc이 참조하는 symbol정보를 가져온다.(sym variable)
      symbol value relocation을한다(val variable)
      loc위치에 val을 write한다.
    *상세내용은 skip...

  line 2406-2416
    get_offset()
       해당 section의 size를 업데이트(=누적)하고,
       해당 section의 offset을 return한다.
      *line 2412는 x86에서는 nop.
  line 2427-2521
    layout_sections
       커널모듈 allocation section(sh_flags에 SHF_ALLOC 플래그가 set)의 layout정보를 세팅한다.
       다음 정보가 세팅된다.
         모든 core allocation section의 sh_entsize : 전체 core allocation section 내에서의 offset을 의미한다.(0부터 시작)
         모든 init allocation section의 sh_entsize : 전체 init allocation section 내에서의 offset을 의미한다.(0부터 시작)
      struct module의 layout size정보도 업데이트한다.
        struct module->core_layout.size/text_size/ro_size/ro_after_init_size 
           전체 core allocation section의 정보
            size : 전체 size
            text_size : exe영역 size
            ro_size : ro영역 size
            ro_after_init_size : ro_after_init영역 size 
        struct module->init_layout.size/text_size/ro_size/ro_after_init_size
           전체 init allocation section의 정보
            size : 전체 size
            text_size : exe영역 size
            ro_size : ro영역 size
            ro_after_init_size : ro_after_init영역 size 
      line 2449-2450
        ko파일의 모든 section의 sh_entsize를 초기화(~0 = 0xffffffff 으로)
      line 2452-2483
         masks의(line 2435-2446 참조) 각 entry 'm'에 대해서(=text, ro, ro_after_init section 각각에 대해)
           ko파일의 모든 non init alloc section(='.init'으로 시작하는 section)의 sh_entsize를(=offset) update.(line 2454-2465)
           struct module->core_layout.size 도 업데이트
            *이 2개 모두 get_offset()에 의해 처리됨
             단, 일부section들은 예외
             non init section이다.(='.init'으로 시작하는 section이 아니다)(by module_init_layout_section)
             masks와 다른 sh_flags를 가지는 section(=allocation section이 아닌 section)
             etc...
           이후 아래 2 필드를 최종적으로 업데이트 한다.
            struct module->core_layout.size : module의 전체 size
            struct module->core_layout.text_size : module의 text(executable) 영역 size
                                       ro_size : module의 read-only 영역 size
                                       ro_after_init_size : module의 ro_after_init 영역 size
      line 2485-2520
        위 line 2452-2483과 기본적으로 동일하다. 
        단 init section에 대해서 수행한다.
         sh_entsize에 최상위 비트에 1을 세팅한다.
         struct module->init_layout.size / text_size / ro_size / ro_after_init_size를 업데이트한다.

  line 2582-2585
    get_modinfo()
      ko파일의 .modinfo section에서 특정 filed의 value를 return한다.

  line 2587-2596
    setup_modinfo()
    struct module의 특정필드에 값을 세팅한다.(by struct module_attribute->setup())
     사실상 struct module->version, srcversion 필드에 strdup하는 수준인 듯.(line 744-745참조)

  line 2699-2754
    layout_symtab()
    ko파일의 symbol 관련 section layout을  init/core allocation section에 추가한다.(젤 마지막에) *layout_sections 와 비슷
    struct load_info의 각 offset 필드도 같이 세팅해준다.~
    *CONFIG_KALLSYMS y이면 동작, 아니면 nop.
    line 2713-2717
      ko의 symbol section의 layout을 init allocation section에 추가/업데이트한다.(젤 마지막에)
    line 2718-2738
      ko의 core symbol의 layout을 core alloction section 에 추가/업데이트한다.(젤 마지막에)
    line 2740-2744
      ko의 string section의 layout을 init allocation section에 추가/업데이트한다.(젤 마지막에)
    line 2746-2753
      mod_kallsyms 정보의 layout을 init allocation section에 추가/업데이트한다.(젤 마지막에)
      
  line 2888-2950
    module_sig_check()
      현재 config로는 nop이긴함.
      그래도 간략하게 보면...
     ko파일로부터 module의 signature(pkcs7 format)을 찾아서 체크를 수행한다.
     line 2896-2910
       module signature check
       ko파일로부터 모듈시그니처를 찾고, 해당 시그니처를 비교한다.(아래 참고 참조)
        시그니처는 PKCS7 포맷(mod_verify_sig() 참조)
       *참고. 커널모듈 시그니쳐 위치 *(module_sig_check, mod_verify_sig에서 len 다루는 코드 참조해서 유추함.)
       ELF header              => lower offset
       ------------------
       ...
       ELF contents
       ...
       ------------------
       struct module_signature => 모듈시그니처
       ------------------
       MODULE_SIG_STRING       => 모듈시그니처 마커(모듈시그니처위치를 찾기 위함, ko파일의 젤 끝에 위치)
       ------------------      => higher offset
    line 2913-2935
      error handling.
    line 2937-2940
      module.sig_enforce 커널파라미터가 set이면, check실패한 signature를 가진 커널모듈은 로드하지 않음.
    line 2942
      security_* function은 LSM(Linux Security Modules)를 의미. skip
      CONFIG_SECURITY가 set되어야 사용, clear면 모두 nop(return 0)임.
      $(top)/Documentation/security/lsm.rst 참조
  line 2967-3099
    elf_validity_check()
      ELF를 체크한다.
      ELF헤더, 섹션헤더, size, machine type, section type 등등을 체크한다.
       유효하지 않으면 error를 return(-ENOEXEC *딴것도있긴함!)
  line 3190-3213
    rewrite_section_headers()
      info->sechdrs 정보를(메모리로 로드한 커널모듈의 ELF section들) rewrite함
         각 section의 sh_addr 필드를 info->hdr(메모리에 로드된 커널모듈(ko파일)) 기준으로 업데이트
        version, modinfo section의 경우 sg_flags 필드에서 SHF_ALLOC을 off함.
  line 3215-3272
    setup_load_info()
      ko파일로부터 섹션정보(index등)를 조회하여 필요한 정보(ex struct module, module이름...)들을 세팅한다.
      line 3227-3230
        ko파일의 .modinfo section에서 'name' field의 value를 가져온다
      line 3232-3247
        ko파일의 symbol table정보를 세팅한다.
         없으면 error를 return(-ENOEXEC)
      line 3249-3256
        ko파일의 .gnu.linkonce.this_module 섹션을 찾고,
        info->mod를 섹션의 시작주소로 세팅한다.
        *.gnu.linkonce.this_module 섹션의경우 struct module 구조체데이타가 존재.($(top)/tools/perf/util/probe-event.c line300, ./scripts/mod/modpost.c line2164-2194참조)
        
      line 3258-3263
        name을 얻어오지못한경우(line 3227-3230참조)
        info->mod로부터 name을 가져온다.
      line 3265-3268
        __versions섹션 index를 찾는다.
         불필요한경우(flag로 세팅) 찾지않음!
      line 3270
        .data..percpu섹션 index를 찾는다.
  line 3275-3317
    check_modinfo()
      ko파일 .modinfo section의 정보(ex. vermagic, intree, staging, livepatch, license)들을 체크한다.
       먼가 맞지 않으면 tainted 표기한다.(by add_taint_module)
      line 3277-3292
        ko파일 .modinfo section중, 'vermagic'이 kernel magic값과 같은지를 체크한다.
      line 3294-3299
        ko파일 .modinfo section중, 'intree'정보를 확인한다. 없으면 tainted 로 표기한다.
      line 3301
        cpu 보안 코드(spectre관련 일단 skip)
      line 3303-3307
        ko파일 .modinfo section중, 'staging'정보를 확인한다. 있으면 tainted 로 표기한다.
      line 3309-3311
        ko파일 .modinfo section중, 'livepatch'정보를 확인한다.
        *livepatch : system reboot없이 patch할수있는 기능. 자세한건 skip. ($(top)/Documentation/livepatch/livepatch.rst 참조)
      line 3313-3314
        license(ex. GPLv2냐...)를 체크한다. 허용되지 않는 license면 tainted로 표기한다.

  line 3319-3425
    find_module_sections()
      kernel module에서 section들의 정보(section의 주소와 section 내 object 갯수)를 struct module 대응하는 필드에 세팅한다.

  line 3427-3488
    move_module()
      ko파일의 섹션들을 새롭게 할당된 메모리영역으로 copy한다.
      line 3433-3444
        ko의 core_layout 영역의 메모리를 할당하고 struct module->core_layout.base에 시작주소를 세팅
        *core_layout은 layout_section 참조
      line 3446-3462
        ko의 init_layout 영역의 메모리를 할당하고 struct module->init_layout.base에 시작주소를 세팅
        *init_layout은 layout_section 참조
      line 3464-3485
        ko파일의 각 section을 위에서 할당된 core_layout, init_layout으로 copy.
        copy시, 각 섹션헤더의 sh_addr필드도 copy된 메모리 위치로 세팅함.
      *참고.
        kmemleak*은 memory leak detction mechanism관련내용임. 자세한건 skip. $(top)/Documentation/dev-tools/kmemleak.rst참조.
        CONFIG_DEBUG_KMEMLEAK config에 따라 기능 on/off됨
  
  line 3490-3523
    check_module_license_and_versions
    kernel module의 license / version을 체크한다.
    체크가 실패한 경우 taint 또는 -ENOEXEC(by try_to_force_load)를 리턴한다.
    line 3492-3513
       특정 kernel module(ex ndiswrapper, driverloader, lve이 load되는 경우, taint한다)
    line 3515-3520
      kernel module 심볼과 version존재유무(=crc정보존재유무)를 체크한다.
      module심볼은 있으나, version이 없으면, try_to_force_load를 호출한다. CONFIG_MODULE_FORCE_LOAD가 noset이면 ENOEXEC를 리턴

  line 3534-3567
    blacklisted()
    커널모듈이름(ko파일로부터 가져옴 by setup_load_info)이 kernel parameter module_blacklist에 등록되었는 지 check한다.
    등록되어있다면 return true, 아니면 return false.
  line 3569-3628
    layout_and_allocate()
      ko의 layout정보를 세팅하고
      layout에 대한 메모리를 할당한 후
       할당된 메모리로 ko각 섹션들을 copy한다.
       이 과정에서, 각 섹션의 일부 필드(sh_addr, sf_flags ...)가 업데이트된다.
      line 3575-3577
        ko파일의 modinfo 정보를 체크한다(by check_modinfo())
      line 3579-3583
        x86에서는 nop function으로 보여짐. skip
      line 3585-3588
        ko파일의 모든 section에 대한 section flag를 체크.(by module_enforce_rwx_sections)
        CONFIG_STRICT_MODULE_RWX를 따르며 off면 nop. on이면 write/exec가능해야함.
      line 3590-3609
        pcpu, .data..ro_after_init, __jump_table section에 대해 특정 section flags를 세팅해줌.
      line 3616
        ko파일의 allocation section에 대한 layout을 세팅한다(by layout_sections)
      line 3617
        ko파일의 symbol관련 section에 대한 layout을 세팅한다.(by layout_symtab)
      line 3619-3622
        ko파일의 섹션들을 새롭게 할당된 메모리영역으로 copy한다.(by move_module)
      line 3625
        struct module->mod의 메모리주소를 세팅한다.(move_module(*line 3619-3622)에 의해 copy된 주소로 세팅)

  line 3646-3660
    post_relocation()
      struct module->extable을 소팅한다.(by sort_extable, 먼진몰라서 분석 skip)
      percpu 섹션데이타들을 pcpu공간에 copy한다.(by percpu_modcopy)
      kallsyms정보를 세팅한다.(by add_kallsyms) *CONFIG_KALLSYMS y이면 동작, 아니면 nop.
        *kallsyms : kernel내부의 모든(all) symbol정보
      x86 module_finalize를 호출한다.(alternative적용 / ORC unwind init등을 수행. 정확한건 skip...)
       *난해해서 일단 상세분석은 skip하고 개요만 확인함

  line 3727-3836
    do_init_module()
      kernel module load를 마무리한다.
       주요 작업들은...
         초기화 function수행(존재한다면, ex. module_init으로 등록된 함수)
        kernel에 noti(???)
         이후 불필요 리소스들 제거
      line 3745
        kernel module의 constructor를 실행한다.(by do_mod_ctors)
        *constructor는 ko파일의 .ctors 섹션을 read하여 세팅된다.(by find_module_sections)
      line 3747-3758
        module_init() macro로 정의된 함수를 실행한다. 없으면 실행안한다.
         실패(retrun < 0)이면, error를 리턴한다.
         *성공은 == 0이고, 0보다큰값은 warning을직는다.(0/-E 리턴 convention을 따라야한다.)
      line 3761
        mod->state = MODULE_STATE_LIVE로 세팅한다.
      rest of line
        현재단계에서는 별로 안궁금... 등록해야할 리소스 등록하고, struct module리소스 해제하는 것들을 수행한다.
      
  line 3838-3844
    may_init_module()
      finit_module수행가능한지 권한 체크
      capability(CAP_SYS_MODULE)와 커널파라미터(modules_disabled)를 체크함

  line 3846-3898
    add_unformed_module()
      struct module->state를 MODULE_STATE_UNFORMED(아직 초기화중이다를 의미, 정의부분 주석참조)로 세팅 후
      modules 에 등록(=커널에 등록)
       만약 동일 커널모듈(커널모듈이름으로 체크함 by find_module_all)이 존재한다면,
       커널모듈로딩이 완료될때까지 기다린 후,(by wait_event_interruptible)
       상태를 체크한다.(로드가되었다면 -EEXIST를 return 아니면, -EBUSY를 return)
      *wait_event_interruptible : condition이 만족할때까지 현재 task를 sleep시킴. condition이 만족하면 깨어나서 중단된부분부터 다시 실행
      *mod_tree_insert는 skip(tree형태 자료구조로 struct module 관리하는 걸로 보여짐... CONFIG_MODULES_TREE_LOOKUP on이어야사용됨)

  line 3900-3930
    complete_formation()
      커널모듈의 complete마무리 작업 후 상태를 MODULE_STATE_COMING으로 업데이트한다.
      line 3906-3909
        kernel module symbol이 이미 커널이미지에 존재하는지를 체크한다. 존재한다면 fail을 return(by verify_exported_symbol)
      line 3911-3912
        kernel module의 bug entry정보를 세팅한다. 자세한건 skip(by module_bug_finalize)
          __bug_table section 정보가 있으면 해당 섹션정보를 struct module->bug_table, num_bugs에 세팅하고,
          struct module을 module_bug_list에 add함.
      line 3914-3916
        kernel module의 각 메모리영역 권한을 세팅한다. 
        CONFIG_STRICT_MODULE_RWX on인경우만 동작한다.
        $(top)/arch/Kconfig 'STRICT_MODULE_RWX'를 참조...
         상세내용은 skip
      line 3918-3922
        kernel module의 state를 MODULE_STATE_COMING으로 업데이트한다.
    
  line 3932-3948
    prepare_coming_module()
      ftrace/livepatch관련 enable/coming작업을 수행 *정확한건 skip

  line 3975-4202
    load_module()
      kernel module에 대한 check(ex. format, signature, symbol version, blacklist, etc...)를 수행하고,
      kernel module의 실행환경 셋업 이후(ex. ko파일로부터 각section정보를 읽고, memory에 load, 이 과정에서 relocation도 일어남.)
      kernel module의 초기화루틴실행(ex. module_init macro로 등록한 것) 및 kernel에 module을 등록한다.
      line 3982-3996
        kernel module signature(pkcs7)를 체크한다.(by module_sig_check)
      line 3998-4004
        ko파일 sanity check를 수행한다.(by elf_validity_check)
        ko파일은 ELF이므로 ELF sanity check를 수0행한다.
      line 4006-4013
         필요한 섹션정보들을 세팅한다(by setup_load_info)
      line 4014-4022  
        kernel module이 blacklist인지 확인한다. blacklist라면 load하지 않는다.
      line 4024-4206
        메모리로 load된 ko파일의 elf섹션중 일부정보(sh_addrs, sh_flags)를 rewrite함(by rewrite_section_headers)
      line 4028-4032
        로드되는 kernel module의 버전을(module_layout symbol을 이용) 체크한다.(by check_modstruct_version)
      line 4035-4039
        kernel module의 layout정보세팅및 메모리를 할당하여, 해당 영역으로 kernel module을 copy한다.(by layout_and_allocate)
      line 4041
        audit log관련... 지금은 skip(ko랑크게 관련없음)
      line 4043-4046
        kernel module을 kernel에 등록한다.(by add_unformed_module)
      line 4048-4056
        kernel module signatrue 체크에 실패했다면(by 젤 처음 module_sig_check), kernel을 tainting한다.
      line 4058-4061
        kernel module percpu 영역을 할당한다.(by percpu_modalloc)
      line 4063-4068
        module의 일부 data들을 초기화한다.
          module unload를 위한 data들을 초기화한다.(by module_unload_init)
          lock을 초기화한다.(by init_param_lock)
      line 4070-4076
        kernel module의 섹션정보들(주소/object갯수)을 struct module의 각 필드에 세팅한다.(by find_module_sections)
      line 4078-4080
        kernel modue의 라이센스 및 버전(=심볼버전)을 체크한다.(by check_module_license_and_versions)
      line 4082-4083
        struct module의 attribute정보를 세팅한다.(by setup_modinfo)
      line 4085-4096
        symbol resolution(relocation포함)을 수행한다.(by simlify_symbols, apply_relocations, post_relocation)
      line 4098
        memory cache를 flush한다. x86은 해당 안하는 듯. 상세내용은 skip~
      line 4100-4101
        cfi를 초기화한다.(by cfi_init) CONFIG_CFI_LANG on인경우만 동작함. 상세내용은 skip~
        *cfi : Clang's Control Flow Integrity 를 의미. $(top)/arch/Kconfig line 725 참조
      line 4103- 4108
        systemcall로 넘어온 argument(uargs)를 copy한다.
      line 4110-4114
        debug를 위한 초기화를 수행한다. *상세내용은 skip 
      line 4116-4119
        kernel module의 마지막 formation을 수행한다.(by complete_formation)
      line 4121-4123
        ftrace/livepatch관련 enable/coming작업 수행(by prepare_coming_module)
      line 4125
        async_probe 설정을 setting.($(top)/Documentation/admin-guide/kernel-parameters.txt 참조)
      line 4127-4137
        kernel parameter를 파싱/세팅한다.(by parse_args) *자세한건 skip함.
      line 4139-4142
        kernel module을 sysfs에 등록한다.(아마 sysfs에 module관련 인터페이스 잡아주고 그런거하는 듯... 자세한건 역시 skip)
      line 4144-4148
        kernel module livepatch관련... 자세한건 skip~
      line 4150-4151
        info resource(struct load_info->hdr)를 free한다.
      line 4154
        tracing log를 출력...
      line 4156
        kernel module load를 마무리한다.(by do_init_module)
      line 4158-4200
        위 과정들에서 할당받은 리소스들(ex. kernel module 메모리공간, lock, list와같은 자료구조 등)을 해제한다.
        
  line 4204-4222
    init_module()
    syscall init_module
    finit_module이랑 거의비슷, 대신 파라미터로 fd가 아닌 load된 커널모듈버퍼가 넘어오고, flag가 없음.
  line 4224-4248
    finit_module()
    syscall finit_module
    line 4230-4232
       권한체크(by may_init_module *line 3838-3844)
    line 4235-4238
      파라미터로 넘어온 flag 체크
      잘못된 flag가 넘어오면 return
     flag의미는 man page(man finit_module)참조하면 됨.
    line 4240-4245
      파라미터로 넘어온 fd 파일을 read한다.
     fd 파일은 커널모듈(.ko)이 넘어온다.(strace -f insmod 로 확인가능)
    line 4247
      커널 모듈을 로드한다.(by load_module)

$(top)/kernel/module-internal.h
  line 11-29
    struct load_info
    주요필드
      name : 커널모듈이름. 일반적으로 빌드 시 ko파일의 .modinfo section에 'name' 필드로 정의됨 (set by setup_load_info)
 
      mod : struct module. 커널모듈 빌드 시, .gnu.linkonce.this_module 섹션에 정의됨(빌드시 생성되는 .mod.c 파일에 의해) (set by setup_load_info)

      hdr : 커널모듈(.ko파일)이 존재하는 메모리의 시작을 가리킴. 즉, ko파일의 ELF header영역을 가리킨다.(set by copy_module_from_user / finit_module)
      len : 커널모듈(.ko파일)의 사이즈.(set by copy_module_from_user / finit_module)
         *커널모듈은 시스템콜(init_module / finit_module)에 의해 메모리로 로드됨
        
      sechdrs : 커널모듈(.ko파일)에서, ELF section header가 존재하는 메모리의 시작을 가리킴.(set by elf_validity_check)

      sig_ok : 모듈 시그니쳐가 정상적으로 verified 되면 true.(set by module_sig_check)
        *signature 체크방법은 module_sig_check함수 참조

      index : 커널모듈(.ko파일)에서, ELF section header entry의 인덱스.(=sechdrs필드를 참조하기 위한 인덱스) (set by setup_load_info)
        sym, str : 심볼테이블 섹션 인덱스
        mod : .gnu.linkonce.this_module 섹션 인덱스
        vers : __version 섹션 인덱스
        info : .modinfo 섹션 인덱스

$(top)/include/linux/module.h
  line 364-541
    struct module
    주요필드
      state : 모듈의 현재 상태(ex. 로드되고있는지, 로드다되었는지 ...). 모듈로드 코드들에서 상태를 업데이트 수행

      list : global한 커널모듈리스트 entry. 리스트에 추가되는 시점에 세팅됨.

      name : 커널모듈이름. 일반적으로 빌드 시 ko파일의 .modinfo section에 'name' 필드로 정의됨(objdump -s [/path/to/.ko]로 확인가능).
               커널모듈빌드시점에 정의된다.
               *아마도, mod.c파일의 KBUILD_MODNAME 일 듯(빌드할때 커널모듈이름으로 치환될 것 같다.)

      syms : 커널모듈 exported symbol. ko파일의 __ksymtab section에 존재.(EXPORT_SYMBOL 매크로를 통해서 symbol이 정의되고 링크시 __ksymtab section으로 링크됨) (set by find_module_sections). 
      num_syms : syms의 갯수.(set by find_module_sections)
      crcs : 각exported symbol에 대한 crc값.(set by find_module_sections)
             ko파일의 __kcrctab section에 존재.(EXPORT_SYMBOL 매크로를 통해서 정의되고 *CONFIG_MODVERSIONS enable이어야 존재. 아니면 없음. 링크시 __kcrctab section으로 링크됨) 
             *crc계산 방법은 잘 모르겠음. skip.

      gpl_syms, num_gpl_syms, gpl_crcs : syms, num_syms, crcs의 GPL버전. (EXPORT_SYMBOL_GPL 매크로를 통해 정의되고 링크시 각 필요한 section들(syms,crcs와 비슷한형태로)로 링크됨)

      sig_ok : struct load_info->sig_ok의 값을 그대로 copy (set by load_module)

      init : 커널 모듈 초기화 함수. module_init 매크로로 정의됨. *8단계 7-2-2 참조.

      core_layout : ko파일의 layout(=섹션종류별)의 정보(위치, 전체크기, 종류별 크기). '.init'으로 시작되는 섹션은 제외하고 계산(set by layout_sections)
      init_layout : core_layout과 의미는 동일. 단 '.init'으로 시작되는 섹션만 계산(set by layout_sections)
         *공통필드(struct module_layout)
        base : 해당 layout의 메모리에서의 시작주소.
        size : ko파일에서 특정섹션(executable, ro(text/ro_data), ro_after_init, etc)들의 전체 size.
        text_size : ko파일에서 특정섹션(executable)의 size
        ro_size : ko파일에서 특정섹션(ro(text/ro_data))의 size
        ro_after_init_size : ko파일에서 특정섹션(ro_after_init)의 size

      taints : kernel module의 taint상태(ex. module signature verifying failed)를 나타냄. bit단위로 다뤄지는 변수임. (set by add_taint_module *커널모듈 로드 로직 곳곳에서 호출 됨.)

7-2-3.
  kernel module unload 로직 개요
    delete_module systemcall을 수행($(top)/kernel/module.c line 912-987)
    struct module을 찾고, 
    module 상태등을 제거중인 상태로 변경(ex struct module->state를 세ㅣ팅),
    exit(module_exit macro에 등록된 것)함수 실행하고,
     관련 리소스들을 해제 및 커널에서 제거한다.
    *만약 이미 제거중이면 로직을 중단(return)한다.
  lsmod/modinfo 로직 개요
    lsmod
      /proc/modules를 기반으로 정보를 보여준다
    modinfo
      kernel module파일(ko파일)을 파싱하여 정보를 보여준다.(이 외 다른 파일들도 쓰는것으로 확인되는데(ex. modules.builtin.bin) 상세한건 일단 skip)
  
  참고.
    insmod / modprobe모두 kmod 오픈소스에 포함됨.
    systemcall은 init_module/finit_module(load), delete_module(unload) 임.
      strace -f insmod하면, 최종적으로 finit_module 시스템콜 호출함을 알 수 있음.
      strace -f rmmod하면, 최종적으로 delete_module 시스템콜 호출함을 알 수 있다.
      modprobe, modprobe -r도 결국 finit_module / delete_module 시스템콜 호출한다.
 
8단계 *목표 : 7단계 부족부분 확인
  7-1-1.
    (v)kernel src tree가 정말 모두 필요한가?(헤더만 있으면 안되는가?)
      헤더만(make headers_install 로 생성되는)으로는 안됨. 커널모듈빌드시 필요한 Makefile들과 tool들도 필요하기 때문임.
      그렇다고 full source가 필요한 것도 아님. but, 커널모듈은 빌드하지만 일부제약이 있음.(ex. module versioning이 동작안함) *(top)/Documentation/kbuild/modules.rst 2. How to Build External Modules 참조!
     full featured로 모듈 빌드하고 싶다면, 커널모듈을 load할 대상의 full src tree(build된)이 필요하다.!

    (v)module signing이란?
      개요 : 커널모듈 설치시점에 서명을 함. 이 후 커널모듈로드 과정에서 서명을 체크해서 커널모듈 로드 or 로드X 를 함.
      상세
       signing 수행
          시점 : module install 시(make modules_install) 수행됨. $(top)/Makefile.modinst line 64-76 참조

          하는일
           $(top)/scripts/sign-file 바이너리를 호출하여 ko파일에 module signature정보를 append함. sign-file.c 참조

           $(top)/scripts/sign-file [해시종류(ex. sha256)] [키파일패스(.pem파일)] [인증서패스(.x509파일)] [커널모듈(.ko파일)] 로 호출됨.

           $(top)/script/sign-file 코드 분석 개요(상세 분석은 X) *$(top)/scripts/sign-file.c, openssl 기반으로 동작
             line 297-357 : ko파일의 signature를(ex. pkcs7) 계산함.
             line 362-373 : signature를 붙이기 위해 ko파일 데이터를 copy
             line 394-397 : module signature를(signature정보와 MARKER string(magic_number 변수)) ko파일에 append. *layout은 load_module()의 module_sig_check 참조

       signing 검증
          시점 : load_module시 module_sig_check 함수에 의해 수행 
          하는 일 : 상세내용은 module_sig_check 분석 내용 참조
      
   (v)module versioning이란? *$(top)/Documentation/kbuild/modules.rst 6. Module Versioning 참조, modpost.c도 참조
      개요
        해당 커널모듈과 커널모듈이로드되는 커널자체가 버전이같냐(=호환되냐)를 체크한다(같으면 로드, 아니면 로드X)!
       CONFIG_MODVERSION option enable이어야 사용됨. 아니면 사용X
        개념은 다음과 같음
          커널모듈 빌드 시 사용된 커널의 버전정보(=커널모듈이 참조한 외부export커널심볼의 CRC값 *커널의 Module.symvers 파일을 참조하여 얻어옴) 커널모듈에 추가.
          커널모듈 로드 시, 버전정보(CRC값) 비교를 수행.
          *전체가아닌 일부 심볼만 버전이 같으면 로드해도되기때문에, 심볼버전을 체크하는 듯.

      상세.(커널모듈의 버저닝 처리 순서)
        커널모듈이아닌 커널이미지자체(+static 커널모듈)에 대해서도 비슷하게 Module.symvers가 생성되고, 커널모듈 빌드시 해당 파일 기반으로 버전관련 정보를 처리한다라고보면 될 듯(로직은 보진 않았으나 이게 없으면 버저닝 동작 할 수가 없음. 자세한건 skip...) *$(top)/Documentation/kbuild/modules.rst 6.1 참조.

       export symbol 정의
         EXPORT_SYMBOL 매크로 *커널 export symbol(ex. 변수/함수)를 정의
           ___ksymtab+[symbol] 섹션에, struct kernel_symbol __ksymtab_[symbol] 변수를 정의. (by __KSYMTAB_ENTRY 매크로)
           ___kcrctab+[symbol] 섹션에, long __crc_[symbol] 변수를 정의(by __CRC_SYMBOL 매크로)
 
           ___ksymtab+* 섹션들은 ko파일의 __ksymtab섹션으로 링크
           ___kcrctab+* 섹션들은 ko파일의 __kcrctab섹션으로 링크
         
         EXPORT_SYMBOL_GPL 매크로 *커널 export symbol(ex. 변수/함수)를 정의
           ___ksymtab_gpl+[symbol] 섹션에 변수 정의(EXPORT_SYMBOL과 동일함)
           ___kcrctab_gpl+[symbol] 섹션에 변수 정의(EXPORT_SYMBOL과 동일함)

           ___ksymtab+gpl* 섹션들은 ko파일의 __ksymtab_gpl섹션으로 링크
           ___kcrctab+gpl* 섹션들은 ko파일의 __kcrctab_gpl섹션으로 링크

       export symbol crc계산
          커널모듈에 링크되는 각각 .o파일에 대해서 빌드 시 생성됨. *symbol의 crc생성은 $(top)/scripts/Makefile.build line 184, $(top)scripts/genksyms/genksyms.c 참조. *상세분석은 skip. 동작으로만 확인함.
         
          각 오브젝트(.o)에 대해서 아래를 수행한다고 보면 됨.

         genksyms tool
           EXPORT_SYMBOL* 매크로에 의해 정의된 각 심볼에 대해 crc값을 계산
           output은 linker script임(__crc* 변수(위 EXPORT_SYMBOL 매크로 내용 참조)에 crc value 값을 세팅)
           ex)
             __crc_export_func = 0x6dd4d6df;
             __crc_export_func2 = 0x245b006c;

          위 linker script기반으로 링크를 다시 수행하여 .o 파일을 재생성
           ex)
             linker script수행전 .o파일의 crc심볼정보 *objdump -t [path/to/object]
               0000000000000000  w      *UND*	0000000000000000 __crc_export_func
               0000000000000000  w      *UND*	0000000000000000 __crc_export_func2

             linker script수행후 .o파일의 crc심볼정보. *symbol value, section type이 변경되었음!
               00000000245b006c g       *ABS*	0000000000000000 __crc_export_func2
               000000006dd4d6df g       *ABS*	0000000000000000 __crc_export_func

       export symbol 버전 정보 출력
         modpost
           $(top)/scripts/mod/modpost -o [Module.symvers출력경로] -e -i [커널이미지의 Module.symvers경로] -T [커널모듈 main 오브젝트파일(.o *모든 커널모듈의 오브젝트들이 링크된)] 로 실행. 
           output은 Module.symvers(해당 모듈의 export symbol 버전 정보(=해당커널모듈의버전))과 mod.c(외부export커널심볼의 버전 정보(=모듈이빌드된커널버전)를 포함)파일.

           $(top)/scripts/mod/modpost 코드 분석 개요(상세 분석은 X) *$(top)/scripts/mod/modpost.c
             line 2514-2521 : 커널이미지의 Module.symvers로부터 각 symbol정보를 read함. 포맷은 '[crc] [name] [module] [export] [ns]' 형태이며 struct symbol 구조체에 읽어진 값을 세팅함.
                                   읽어들인 심볼(struct symbol*) 과 심볼을 포함하는 모듈정보(struct module*)를 자료구조에 insert.
                                 struct module *modules : 심볼 포함하는 모듈
                                 struct symbol *symbolhash : 심볼
                        
             line 2526-2527 : 커널모듈의 main 오브젝트파일(.o파일)을 read함.(ELF포맷을 reading / parsing)
                              read된 정보를 다음 자료구에 insert
                                struct module *modules : 해당 커널모듈.
                                struct module->unres : 해당 모듈에 정의되지 않은 심볼.(=외부 커널 심볼)
                                struct symbol *symbolhash : 해당 모듈에서 EXPORT로 정의된 심볼 with CRC value.
                                struct module->srcversion : 해당 모듈에 포함된 오브젝트파일경로(string, .mod 파일)에 대한 md4 hash

             line 2529-2551 : 위 내용 기반으로 mod.c 파일 생성(write)
                              version관련 write되는 정보는 다음과 같음.
                                struct modversion_info ____versions[] //__version 섹션
                                       외부 커널 심볼의 crc, name 배열.
                                       이게 진짜 커널모듈 로드시 사용하는 버전정보!!!!!!!!!!!!!!!!!!!
                                MODULE_INFO(srcversion, struct module->srcversion);
                                       커널모듈의 srcversion
                                       이건 다른거임... 커널모듈버저닝에서는 무시해도 됨.!

             line 2556-2557 : Module.symvers 파일(=자기자신에 대한 버전정보) 생성(write). *$(top)/Documentation/kbuild/modules.rst 6.2 참조
                                  포맷은 '[crc] [name] [module] [export] [ns]'
                              line 2514-2521에서 읽어들인 symbol정보는 제외됨. =>  해당 커널 모듈의 심볼만 포함.

      export symbol 버전 정보 check
        load_module() 시, check_version()으로 비교함.
          by check_modstruct_version() *layout_module symbol만 비교
          by simplify_symbols()  *ko파일에서 UND 섹션 symbol만 비교
               resolve_symbol_wait()
                 resolve_symbol()

    (v)modpost란 정확히 뭔가? 
     커널모듈 빌드 시, 커널모듈의 버전정보와 mod.c파일을 생성하는 tool *8단계 module versioning의 modpost분석내용 참조.
     $(top)/scripts/Makefile.modpost 에 의해 실행됨.
     
    (v)rule_cc_o_c 정확히 하는 역할? *$(top)/scripts/Makefile.build 참조
       커널의 소스코드 컴파일하기 위한 make 매크로. *커널모듈만 해당하는 게 아님.
       단순히 .c->.o만 수행하는 것은 아니고 모듈버저닝정보 생성 등을 수행한다. *상세내용은 범위를 넘으므로 skip.
  
    (v)$(output_top)/scripts/module.lds 의미..
      .ko파일에 커널모듈에서 나중에 필요한 정보들(ex. 커널모듈이 정의한 export심볼/심볼의crc(버전정보)) 등등)을 link(aggregation)함.
       커널모듈 로드시 load_module()과정에서 여러군데에서 사용됨.(ex. __ksymtab섹션은 find_symbol 함수참조) *상세한 건 skip

  (v)7-2-1.
    (v)mod*(modprobe, modinfo)과 *mod(ex. insmod, rmmod, lsmod) 차이
      insmod/rmmod vs modprobe/modprobe -r : 궁극적으로 시스템콜(finit_module, delete_module)을 통해 모듈 load/unload하는건 동일하다. 대신 application단 동작이 다르다.!
      lsmod vs modinfo : 용도자체가 다름. lsmod는 커널내 모듈 리스팅(/proc/modules), modinfo는 커널모듈로부터 정보를 읽어서 보여줌.

  (v)7-2-2.
    (v)do_init_module(line 3747-3758)
      (v)module_init 매크로와 do_one_initcall의 관계.
         개요는 다음과같음
           커널모듈소스코드 .c파일내 module_init(my_module_init) 매크로 기술. 
           커널모듈 빌드가 수행되며 위 .c파일 module_init macro expansion시, init_module()은 my_module_init()에 대한 alias하는 코드가 됨.
          .mod.c파일이 빌드과정에서 자동생성되며, 여기에 struct module 구조체가 정의됨(.gnu.linkonce.this_module section에). 주요 필드는 다음과 같음
            .init = init_module     // init_module == my_module_init
            .exit = cleanup_module  // 구조는 init과 동일!
            위 모듈코드(.c, .mod.c)들로 ko파일 빌드됨.
            최종적으로, ko파일의 .gnu.linkonce.this_module section에 바이너리로 위 정보가 세팅되게됨!
            이후 해당 ko파일 메모리로 load. by systemcall(ex. finit_module)
           load시 .gnu.linkonce.this_module정보를 읽어서 적절히 메모리로 로드하게되고, do_one_initcall()에 의해 module_init() 매크로 인자로넘긴 함수가 실행된다!

        module_init 매크로 : init_module() function을 
                           kernel module소스코드의 module_init매크로 인자에 대한 alias(아래참조)로 정의함.
                           *module_exit도 동일한 구조임.

        .mod.c : struct module 구조체변수(__this_module)를 정의한 파일.
                   커널모듈빌드시 자동생성됨. *$(top)/scripts/Makefile.modpost참조.
        
        .mod.c에 왜 .init = init_module 로 세팅되는 지? *100%는 아니지만 90%이상 적중은 될 듯!
            모듈개발자가 작성한 소스내의 module_init매크로로 선언하는 함수 symbol은 랭귀지레벨에서 커널코드상으로 알 수 없어서임.
          init_module symbol과 module_init매크로로 선언하는 함수 symbol은 alias이므로 정보는 동일하며(아래 참고. objdump~ 참조),
            모듈 load시 relocation이 일어나도 똑같은 심볼이므로, 
            코드상으로는 do_one_initcall을 통해 struct module->init(즉, init_module)을 호출하는 것이지만, 
            최종적으로는 module_init매크로로 선언된 함수가 실행된다.!
        
         테스트용 커널모듈에서 printk()로 출력한 custom_init()과 init_module()의 address. 같음을 알 수 있다!
          [ 1721.815624] Hello world driver loaded., custom_init:00000000a7dc7f30, init_module:00000000a7dc7f30
           관련코드일부
            static int __init custom_init(void) { // init function!
              printk(KERN_INFO "Hello world driver loaded., custom_init:%p, init_module:%p\n", custom_init, init_module);
              ...
             }
             module_init(custom_init); //init_module alias로 정의!

         참고. gcc alias attribute
           특정 함수 declaration을, 이미 정의된 다른 함수와 동일하게 해줌.(다른 symbol이지만 동일한 함수(=address)를 의미)
          ex) void a() { //do something }
              void b() __attribute__((alias("a"))) // a();, b(); 모두 동일 함수임.

         참고. objdump -t my_module.ko로 확인한 init_module, custom_init(module_init매크로로 선언하는 함수)의 symbol 정보.
          visibility(local / glboal)랑 symbol name빼고 모두 동일 함!
          0000000000000000 l     F .init.text	0000000000000032 custom_init
          0000000000000000 g     F .init.text	0000000000000032 init_module

    (v)struct load_info, struct module 각 필드 및 관련 자료구조(ex. modules) 내용 정리.
      (v)module load시 layout도 정리(할수있었으면 좋겠다 제발)

(v)9단계 *목표 : 예제보지말고, kernel소스트리만(./Documentation도 포함 ㅋ)참조하여 hello.ko kernel module 구현하여 load(load하면 helloword띄우고, unload하면 byeword띄우고...하는 수준)
코드
-Makefile
obj-m := knwtest.o
knwtest-y := main.o

-main.c
#include <linux/module.h>

MODULE_LICENSE("knwtest license");

int knwtest_init(void)
{
        printk("This is the knwtest. Hi!\n");
        return 0;
}

void knwtest_exit(void)
{
        printk("This is the knwtest. Bye!\n");
}

module_init(knwtest_init);
module_exit(knwtest_exit);

-dmesg출력
[  155.577865] knwtest: loading out-of-tree module taints kernel.
[  155.577877] knwtest: module license 'knwtest license' taints kernel.
[  155.577890] Disabling lock debugging due to kernel taint
[  232.321370] This is the knwtest. Hi!
[  238.937113] This is the knwtest. Bye!

10단계 *목표 : 정리
  알게된 것
    커널모듈 빌드 방법
    커널모듈 빌드 로직(make)
    커널모듈 로드 로직
      모듈싸이닝
      모듈버저닝
     module_init/exit 매크로
    커널모듈 유틸(insmod, lsmod, rmmod, modprobe)

  코멘트
    잘된거
      커널모듈 빌드/로드/관련유틸/일부개념(싸이닝,버저닝)에 대해 기본적인 내용을 코드로 분석해보았다. 이후 디테일한 분석에 좋은 시발점이 될 듯.
    안된거
      기본적인 내용(간단한 형태의 모듈(파일1개만존재)에 대한...) 중 일부만 확인했으며, detail한 부분과 분석중 마주친 다른 영역들(ex. sysfs관련 코드 등등) 은 좀 더 확인이 필요하다.
      너무 오래걸리다보니(=호흡이길다) 지쳐서 일관성(봐야하는데 skip or 대충만보고넘어감) 유지가 잘 안된 듯... 좀 더 인내심을 가지는것도 좋을듯.
    
