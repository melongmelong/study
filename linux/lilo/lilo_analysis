first.S
  _main 
    start label 로 jmp.

  start
    ss = BOOTSEG(0x7c00)
    sp = SETUP_STACKSIZE(2048)

    dx,bx,es,si reg값을 push

    ds = BOOTSEG(0x7c00)
    bp = 0

    video관련 설정을 수행.

    ah = dl 수행  후 call bout 수행
    al = 'L' 이후 call display수행.(화면에 L을 출력)

  lagain
    pusha
    
    es = ds(0x7c00)
    
    cmp dl, EX_DL_MAG(0xfe). magic number를 비교. *BIOS에서 dl에 넘겨준 drive로 load할지말지를 결정.
    if(dl != EX_DL_MAG)
      jmp boot_in_dl
    dl = dh

  boot_in_dl
    bx = map2(first.S의 마지막 위치.)
    dh = d_dev의 값(0x80)
    
    ax = dx (ah = dh, al = dl)
    ax 값에 대해 조건을 비교하여 use_installed 로 jmp수행.

    if(prompt != FLAG_MAP_ON_BOOT)
      jmp use_boot
    
  use_installed
    dl = dh
    esi = map_serial_no
    if(esi == 0)
      jmp done_search

    push dx

    int 0x13(ah=0x8, dl=0x80 수행. drive parameter를 read. 하드디스크의 수를 dl에 저장)
    if(fail)
      jmp error

    cx = dl(0x13 bioscall을 통해 hard drive number를 얻어옴)
    
    dx = device, flag 정보를 copy(0x80 - 1)

  vagain (각 disk drive의 첫번째 sector를 read/check하여 load할 disk drive를 찾음.)
    drive개수만큼 아래 task를 반복함.

    dx = dx+1;(다음 drive number)
    call disk_read(ax = 1(read할 sector address), es = ds(0x7c00), bx = map2, dx = (dh = 0x00, dl = 0x80)). hdd 에서 CHS(0/0/1) sector정보를 0x7c00:map2로 읽어옴.

    if(map_serial_no == map2[PART_TABLE_OFFSET-6]). disk signature를 비교.
      jmp vol_found
    else
      jmp vagain

    pop dx
    
  vol_found, done_search, use_boot. (2nd stage를 loading하기 위한 정보를 (2nd stage index sector) load함.)
    push bx (map2)

    dh, si(d_addr, sector address를 가지고 있는 address) 에 disk 관련 flag/addr정보를 setting
    call pread (disk address(ds(0x7c00):d_addr)로부터 1개의 sector를 0x7c00:map2 로 read)
      *ax = (read할 sector address. d_addr), es = 0x7c00, bx = map2, dx = (dh = d_flag), dl = drive

    if(bx-4 != "LILO")
      jmp error

    pop si (si = map2)
    
    es = SETUP_STACKSIZE/16 + BOOTSEG + SECTOR_SIZE/16*2
    bx = 0
    
  sload (vol_found에서 load한 정보를 통해(read할 sector addres), 2nd stage를 load함.)
    call pread
      *ax = (read할 sector address. ds(0x7c00):si(map2)), es = (SETUP_STACKSIZE/16 + BOOTSEG + SECTOR_SIZE/16*2), bx = 0, dx = (dh = d_flag), dl = drive
      *bx는 pread에 의해 512bytes씩 증가함.
    jnz sload

    1st, 2nd signature를 서로 비교.(es(위에서 설정된 값):di(sig), ds(0x7c00):si(sig))
    if(fail)
      jmp error
  
    push es
    push bp
    
    'I'를 출력

    retf(jump to ES:BP). second.S 코드가 실행 됨. 

  disk_read
    input : dh : disk flag(ex. disk addressing(CHS, LBA, Linear....))
            dl : disk drive
            eax: CHS addr
            es : destination buffer
            bx : destination buffer
    *disk_read -> disk_geometric -> disk_int13 -> disk_okay(CHS addressing read시 흐름.). disk_read 에 전달된 input 값들을 각 label에서 사용함.

    stack에 register data를 push
      pusha
      push bp
      push bp
      push eax
      push es
      push bx
      push 1
      push 16
    si = sp
 
    push bx

    if(!(dh == LINEAR_FLAG | LBA32_FLAG))
      jmp disk_geometric
    else if(!(dh == LBA32_FLAG))
      jmp disk_convert

    int 0x13(ah=0x41, bx=0x55AA, disk extension정보를 조회)
    if(disk extension not present)
      jmp disk_convert
    else
      if(bx != 0xAA55)
        jmp disk_convert
      if(cl != EDD_PACKET)
        jmp disk_edd

    *즉, disk_convert, disk_geometric, disk_edd 중 어디에 jmp를 할지를 결정

  disk_geometric
    input : disk_read 참조
    eax reg를 이용하여 cx, dh 설정. 즉, eax를 파라미터로 받아서, CHS address를 구함.

  disk_read2
    ax = 0x201. 즉, 1개의 sector를 read.
    jmp disk_int13

  disk_convert
    push dx, es
    int 0x13(ah = 8, drive parameter를 읽음.)
    pop es

  disk_error3
    if(CF == 1)
      jmp error

    di = number of cylinder(disk_convert에서 int0x13의 결과인 cx reg로부터 구함)
    ax = number of heads(disk_convert에서 int0x13의 결과인 dx reg로부터 구함)

    cx = number of sectors(disk_convert에서 int0x13의 결과인 cx reg로 부터구함)

    ax = al(number of heads) * cx(number of sectors)
    bx = ax

    ax = si[edd_d_addr]
    dx = si[edd_d_addr+2]

    if(dx >= bx)
      jmp disk_error2

    div bx(al = ax/bx, ah = ax%bx)

    if(ax > di)
      jmp disk_error2

    jmp disk_read2

  disk_int13
    input : disk_geometric 참조
    pop bx(target address to read)
    bp = 5

  disk_retry
    pusha
    int 0x13
    if(CF == 0)
      jmp disk_okay
    bp--
    if(bp == 0)
      jmp disk_error3

    int 0x13(ah=0, disk초기화수행)
    popa
    bp--
    jmp disk_retry

  disk_okay
    stack 에 대해 pop수행.
    ret

  pread
    *input : ds : read할 sector addr을 가지고있는 memoy location
            si : read할 sector addr을 가지고있는 memoy location
    *disk_read로 jmp하므로, pread 이전 disk_read에 필요한 input들이 설정되어야 함.

    lodsb
      *다음 2개의 instruction으로 생각하면 됨.
         al = ds:si
         si = si+1
 
    if (eax == 0)
      jmp done

    eax = eax + raid (read할 CHS address를 구함.)
    call disk_read

    bh = bh + SECTOR_SIZE/256 (bx = bx+512)
    *ds:si로부터 read할 CHS addr정보를 가져온 후 1개의 sector를 read하고 bx를 512byte 증가

  done
    ret
      
  bout, nout : hex value를 출력하는 듯.

  display
    bioscall(0x10)을 사용하여 al reg의 값을 출력.
    NOVGA(LCF_NOVGA 가 정의되어있는 경우)인 경우는 아무것도 수행하 지않음.

second.S


bootsect.S
  _main
    ds = #BOOTSEG (0x07c0).
    
    int 0x12 수행.(ax=total low-memory(<=1MB) in KBytes)
    ax=ax-STK_SIZE수행.
    ax=ax<<6 수행
    bx=#INITSEG 수행
    ax=ax>bx ? bx : ax 수행. 일반적으로 bx값이 작을 것으로 보임.

    es = INITSEG 수행.
    BOOTSEG(0x07c0) -> INITSEG(0x9000) 로 512 bytes를 copy.

    ds = ss = ax(INITSEG. 0x9000) 수행.
    di = STK_SIZE-12 수행.
    sp = STK_SIZE-12 수행.
    INITSEG:go label로 far jump수행.(cs = INITSEG 가 됨.)

  go
    ax=ax+0x20 수행. 즉, 0x9020.
    setupseg(jmpi    0,SETUPSEG instruction의 operand에 대한 주소로 보임) = 0x9020수행.
    
    new parameter tables 정보를 setting함.
      ds, cx 를 stack에 push
      pop ds 수행.(cx가 pop 됨.)
      physaddr 0x78로부터 ds, si를 load.
      cl = 6 
      push di.(STK_SIZE-12)
      from ds:si to 0x9000:STK_SIZE-12로 12bytes copy수행.
      STK_SIZE+4에 36값을 설정.(patch sector count)
      pop di, pop ds 수행.
      fs reg를 설정.

  load_setup
    bios call을 사용하여, disk로부터 setup-sector를 read함.
      0x9000:0x0200(0x90000+0x200 = 0x90200)으로 SETUPSECS개의 sector들을 read.
    read실패했을 경우 jmp load_setup하여 계속 read를 시도.
    read성공시, ok_load_setup으로 jmp

  ok_load_setup
    si = disksizes address 수행.

  probe_loop
    36, 18, 15, 9 번째 각 sector에 대해 read try수행함.(최대 몇개의 sector를 읽을 수 있는 지 test를 하기 위해서 인 듯)
    sectors = disksizes를 수행(read성공 시의 sector number(36, 18, 15, 9)
    bh = setup_sects+1 << 1, bl = 0 을 dest addr 지정.(즉, load_setup에서 읽어들인 sector의 다음 load할 address(ex. setup_sects=1인경우, 0x90200~0x90400(by load_setup), bx=0x90400~(by probe_loop)))
    read성공한 경우, loop를 종료.

  got_sectors
    bios call사용하여 "Loading" msg를 출력
    
    es = SYSSEG수행(0x1000)

    call read_it 수행
    
    SETUPSEG(0x9020:0x0000)로 jmp. linux의 경우, arch/x86/boot/header.s의 _start label을 수행하게 되 는듯.

  read_it
    sread = setup_sects + 1
    es 가 64KB boundary인지 확인. 실패시, die를 수행.
    
    bx = 0 수행.

  rp_read
    ax = INITSEG-SYSSEG
    cmp ax, syssize(default 0x8000, build옵션에따라 달라짐)비교하여 ax<=syssize인경우 ok1_read수행. 아니라면 ret 수행.

  ok1_read
    ax = sectors - sread
    cx = ax

  ok2_read
    call read_track
        
  ok4_read
      

  ok3_read
      

  read_track
    msg 출력.

    dx = head
    dh = dl
    dx = dx & 0x0100 

    dh = hea

    int 0x13 수행
    실 패시 bad_rt 로 jmp. 성공시 ret.
    
  die:
    jne die를 수행.
    
*주요흐름정리
vagain : 적절한 disk를 find하기 위해 각 disk의 1번째 sector를 map2(MBR 이후 memory영역)에 load하여 check 수행
vol_found : 해당 disk로부터 d_addr(2nd stage index sector)를 map2(MBR 이후 memory영역) 에 load.
sload : 2nd stage index sector정보로부터 2nd stage가 존재하는 disk sector addr를 read하여, 해당 sector들을 vagain에서 찾은 disk로부터 memory로 읽어들임(es:0x0000 ~)
  
CHS 관련
chs는 hdd의 데이터에 addressing을 하는 방법. 예전에 사용되던 방법임.
head, cylinder, sector로 addressing.

sector : chs addressing에서 sector number는 1부터 시작함. 6bits로 encoding되며 track당 63개의 sector를 가지게 됨.

cylinder : hdd에서의 데이터의 영역. hdd의 모든 platter의 track을 의미함.
0부터 counting됨.
10bit(1024개)  로 cylinder를 addressing함.

head : 실제데이터를 read/write하는 device.
일반적으로 platter당 2개의 head(앞/뒤)를 가짐.
8bits 를 사용. 0~255(256개)를 가짐. 하지만 버그가 있어서 255개(0~254)를 사용함.

24bits로 CHS addressing이 됨.
cylinder(10)/head(8)/sector(6)

ATA spec에서는 28 bits로 addressing을 수행함.
cylinder(16)/head(4)/sector(8)

CHS addressing to LBA addressing
아래 공식을 따라서 변환.
CHS tuples can be mapped onto LBA addresses using the following formula:
A = (c ⋅ Nheads + h) ⋅ Nsectors + (s − 1),
where A is the LBA address, Nheads is the number of heads on the disk, Nsectors is the maximum number of sectors per track, and (c, h, s) is the CHS address.
    
bootsector관련
  computer의 firmware에(일반적으로 BIOS) 의해 memory에 load되어 실행되는 코드. persistent disk에 포함되어있음. 
  IBC-PC compatible machine의 경우, BIOS가 disk 의 첫번째 sector를 boot sector로 사용함. 해 boot sector은 0x7c00에 load됨. 다른 시스템은 다른 spec을 가짐.

  partition table
    disk는 여러 partition으 로나뉘어질 수 있음.
    정보를 어떻 게저장하는 지에 따라 MBR, VBR 로나뉘어짐.
    MBR : partition된 disk의 첫번째 sector. active partition을 찾고 VBR를 실행하는 코드 를가지고 있음
    VBR : 파티션되지않은 disk의 첫번째 sector, 또는 파티션 된각 파티션의 첫번째 sector. OS를 load하기 위한 code를 포함함.
    IBM-PC compatible boot loader 의경우, 0x55AA라는 signature 값을 가지고있음.
    signature는 대부분 BIOS에 의해서 check되며, MBR boot loader에서도 boot sector로 control을 넘기기 전 check됨.(foloppy는 다른 방법으로 check를 수행함)
    BIOS 또는 MBR이 valid boot sector 를 찾지못하는 경우, 다음 device에 대해서 boot을 시도함. 그리고 모든 device에 대해 실패 시, error msg를 띄우거나, fallback routing을 실행하거나 reboot을 하거나 함.

  IBM-PC compatible system BIOS의 경우,
  첫 번째 sector를 무조건 load하며, device type에따라 MBR(hard disk), VBR(floppy/usb flash drive)인지를 구분함.
  해당 sector는 disk partitiong을 이해하고, active partition(boot 을위해 설정된 primary partition 을 의미)의 VBR을 load/run 을수행하는 코드임.
  VBR은 2nd-stage bootloader를 disk의 다른 영역에서 로드함.
  
VBR관련
  bootsector의 종류. 
  IBM PC에서 소개됨.
  파티션된 device 또는(각 파티션 첫번째 sector, 이 경우 disk의 첫번째 sector는 MBR임.) 파티션되지않은 deivce에(device의 첫번째 sector) 존재.
  bootstrapping program의 code를 포함.
  VBR code는 firmware 또는 MBR 코드 또는 boot manager(known as chainloading)에 의해서 직/간접적으로 실행됨.
  
  Signature
    IBM PC compatible system에서는 0xAA55라는 signature가가 boot sector의 끝부분에 위치함.
    signature는 대부분 BIOS에 의해서 check되며, MBR boot loader에서도 boot sector로 control을 넘기기 전 check됨.(foloppy는 다른 방법으로 check를 수행함)
    BIOS 또는 MBR이 valid boot sector 를 찾지못하는 경우, 다음 device에 대해서 boot을 시도함. 그리고 모든 device에 대해 실패 시, error msg를 띄우거나, fallback routing을 실행하거나 reboot을 하거나 함.

  Invocation
    VBR의 boot code는 BIOS가 data, interrupt, hardware초기화를 했다고 가정할 수 있음.
    32KB 이상 memory를 사용하기 위해서는 int 12h 를 통해 query가 필요.
    CPU가 8088/8086 이상이라거나, 하드웨어, 인터럽트, 스택 등의 상태에 대해서 정확한 상태를 예측할 수는 없음.
    일부 register는 BIOS 또는 MBR code에 의해서 초기화되며, 대략 아래와 같음
      cs:ip : 0000h:7c00h
        VBR 은 0000h:7c00h 에 로드 되며(BIOS/MBR code에 따라 서7c00h:0000h 를 사용할 수도 있음), BIOS/MBR code에 의해 해당 위치로 jmp함.

      dl : boot drive unit
        floppy 00h, 01h, ...
        fixed/removable disk 80h, 81h ...
        BIOS종류에 따라 다른 값으로 설정하는 경우도 있음. 

      dh : int 13h를 통해 지원되는 evice 정보.

      es:di : "$PnP" installation check structure
        PnP BIOS 가 PnP Data를 제공할 경우

      ds:si : MBR partition table 정보.
        VBR이 MBR에 의해 실행되었을 경우 제공 되 정보

      등등 특정 feature들이 제공되는 경우 추가적으로 레지스터에 제공되는 정보들이 있음...

MBR관련    
  bootsector의 종류. partition된 디스크의 첫번째 boot sector임. partition되어있지 않는 disk에는 존재하지 않음.
  MBR은 다음 정보들을 가지고 있음.
    partition/filesystem이 어떻게 구성되어있는 지에 대한 정보를 가지고 있음.
    loader로써 동작하는 code.(2nd stage를 로드하거나 VBR을 사용함.)
  partition마다 2TB의 제약사항이있음. 이를 해결하기 위한 방법이있지만 호환성이 없음. GPT가 MBR을 대체하고있으며, MBR 과 일부 호환성을 가짐.

  MBR은 다음의 데이터들로 구성되어있음.
    MBR size는 512bytes보 다 클 수있음.
    partiton table : disk의 partition정보
    Bootstrap code : bootable partition과 VBR를 load하는 code들.
    32bit disk timestamp(optional)
    32bit disk signature(optional)

  disk partitionig
    MBR에는 partition 정보들이 있음.(partition table)
    각 partition들은 다양한 정보들을 포함함
    MBR은 disk의 첫 번째 sector에 위치함.
    
    sector layout
      4개의 primary partition을 사용할 수 있음.
      MBR구조는 wiki참조필요.

    partition table entries
      CHS -> LBA -> GPT 로 발전해옴.
      capacity, MBR 제약 등의 이유로 발전함. ㅎ.ㅎ;

  System bootstrapping
    IBM PC-compatible BIOS의 경우,
    BIOS가 MBR을 load하여 실행.
    MBR은 partition table등의 정보와 boot code를 함께가지 고있으므로, boot code는 일반적으 로 VBR code을 load하고 실행함.(chain-loading이라고 함. active partition으로부터 VBR을 load)
    MBR code는 x86의 경우, real-mode로 실행 됨.
    MBR말고 다른 방식도 존재함.(ex. EFI, 또는 x86이 아닌 다른 architecture...)
 
  Disk Identity
    MBR은 boot code 와 partition table말고도 disk signature정보를 가지고 있음.
    disk medium을 구분하기 위한 32bit value임.
    주로 windows에서 사용하며 linux에서도 어느 disk 를부팅해야되는 지를 알기 위해서 사용함.

  Programming Consideration
    MBR 은 IBM-PC compatible하며, IMB-pc compatible한 시스템은 Little Endian방식을 사용함. 즉, MBR도 Little endian 으로 데이터를 저장함.
    
    BIOS는 disk의 첫번째 sector인 MBR을 0x0000:0x7c00 으로 load한 후, signature를 확인하고나서, 해당 address로 jump.
    
    BIOS의 경우 removable disk(ex. floppy), fixed disk 를 구분하지 않고 동작함. 즉, removable disk의 VBR 코드나, fixed disk의 MBR 코드나 OS에대한 chainn loading을 수행함.
    
    MBR의 마지막 66bytes는 partition table이 위치하므로, MBR에 포함된 code는 446bytes보다 작아야함.
    
    MBR은 partition table을 check하고 active partition으로부터 VBR을 load하고(일반적으로 1sector, 512bytes) run함.
    VBR도 0x0000:0x7c00 에 load가되며, memory에 존재하는 MBR코드는 다른 영역(0x0000:0x0600)으로 relocated 됨.
    
    partition table의 status field를 통해 active partition을 구분함.
    0x00(not active), 0x80(active)이 아닌 값은 invalid함.
    
    BIOS to MBR interface
      BIOS -> MBR 실행시, 어떤 레지스터에 어떤 값 이들어가는 지 등에 대한 설명.
      MBR wikipedia 참조

    MBR to VBR interface
      MBR->VBR 실행시, 어떤 레지스터에 어떤 값 이들어가는 지 등에 대한 설명.
      MBR wikipedia 참조
    
    
